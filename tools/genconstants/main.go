// Code generator for constants.yaml -> constants_gen.go
// Usage: genconstants -in libs/constant/constants.yaml -out libs/constant/constants_gen.go
package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"gopkg.in/yaml.v3"
	"os"
	"sort"
	"strings"
	"time"
)

type Spec struct {
	Version   int         `yaml:"version"`
	Enums     []EnumSpec  `yaml:"enums"`
	Constants []ConstSpec `yaml:"constants"`
}

type EnumSpec struct {
	Name        string      `yaml:"name"`
	Description string      `yaml:"description"`
	Values      []EnumValue `yaml:"values"`
}

type EnumValue struct {
	Name        string `yaml:"name"`
	Value       string `yaml:"value"`
	Description string `yaml:"description"`
}

type ConstSpec struct {
	Name        string        `yaml:"name"`
	Group       string        `yaml:"group"`
	Wire        string        `yaml:"wire"`
	ValueKind   string        `yaml:"value_kind"`
	Description string        `yaml:"description"`
	Vars        []TemplateVar `yaml:"vars"`
}

type TemplateVar struct {
	Name        string `yaml:"name"`
	Kind        string `yaml:"kind"`
	Description string `yaml:"description"`
}

func main() {
	in := flag.String("in", "", "input YAML spec path")
	out := flag.String("out", "", "output Go file path")
	pkg := flag.String("package", "constant", "Go package name for generated code")
	flag.Parse()

	if *in == "" || *out == "" {
		flag.Usage()
		os.Exit(2)
	}

	data, err := os.ReadFile(*in)
	must(err)

	var spec Spec
	if err := yaml.Unmarshal(data, &spec); err != nil {
		must(fmt.Errorf("parse yaml: %w", err))
	}

	must(validate(spec))

	code := generate(spec, *pkg, *in)

	must(os.WriteFile(*out, []byte(code), 0o644))
}

func must(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

func validate(spec Spec) error {
	seenNames := map[string]struct{}{}
	for _, c := range spec.Constants {
		if c.Name == "" {
			return errors.New("constant with empty name")
		}
		if _, ok := seenNames[c.Name]; ok {
			return fmt.Errorf("duplicate constant name: %s", c.Name)
		}
		seenNames[c.Name] = struct{}{}
		switch c.Group {
		case "annotations", "labels", "nats_subjects", "kv_buckets", "subject_templates":
		default:
			return fmt.Errorf("unknown group %q for %s", c.Group, c.Name)
		}
		if c.Wire == "" {
			return fmt.Errorf("wire empty for %s", c.Name)
		}
	}
	return nil
}

func generate(spec Spec, pkg, sourcePath string) string {
	var buf bytes.Buffer
	now := time.Now().UTC().Format(time.RFC3339)
	fmt.Fprintf(&buf, "// Code generated by genconstants; DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// Source: %s\n", sourcePath)
	fmt.Fprintf(&buf, "// Generated at: %s\n\n", now)
	fmt.Fprintf(&buf, "package %s\n\n", pkg)
	// Import fmt only if needed for subject template formatting.
	needsFmt := false
	for _, c := range spec.Constants {
		if c.Group == "subject_templates" {
			needsFmt = true
			break
		}
	}
	if needsFmt {
		fmt.Fprintf(&buf, "import \"fmt\"\n\n")
	}

	// Type declarations
	typeMap := map[string]string{
		"annotations":       "AnnotationKey",
		"labels":            "LabelKey",
		"nats_subjects":     "NatsSubject",
		"kv_buckets":        "KvBucket",
		"subject_templates": "SubjectTemplate",
	}
	var groups []string
	for g := range typeMap {
		groups = append(groups, g)
	}
	sort.Strings(groups)

	for _, g := range groups {
		fmt.Fprintf(&buf, "type %s string\n\n", typeMap[g])
	}

	// Collect constants per group
	perGroup := map[string][]ConstSpec{}
	for _, c := range spec.Constants {
		perGroup[c.Group] = append(perGroup[c.Group], c)
	}
	for g, list := range perGroup {
		sort.Slice(list, func(i, j int) bool { return list[i].Name < list[j].Name })
		perGroup[g] = list
	}

	// Emit const blocks
	for _, g := range groups {
		list := perGroup[g]
		if len(list) == 0 {
			continue
		}
		fmt.Fprintf(&buf, "const (\n")
		for _, c := range list {
			typ := typeMap[g]
			fmt.Fprintf(&buf, "\t// %s: %s\n", c.Name, sanitizeComment(c.Description))
			fmt.Fprintf(&buf, "\t%s %s = %q\n", toExported(c.Name), typ, c.Wire)
		}
		fmt.Fprintf(&buf, ")\n\n")
		// Slice export
		fmt.Fprintf(&buf, "var All%s = []%s{\n", toPlural(typeMap[g]), typeMap[g])
		for _, c := range list {
			fmt.Fprintf(&buf, "\t%s,\n", toExported(c.Name))
		}
		fmt.Fprintf(&buf, "}\n\n")
	}

	// Template builders (forward only)
	if ts := perGroup["subject_templates"]; len(ts) > 0 {
		for _, t := range ts {
			// Build function name: strip _TEMPLATE suffix
			base := strings.TrimSuffix(toExported(t.Name), "Template")
			if base == toExported(t.Name) && strings.HasSuffix(base, "Template") {
				base = strings.TrimSuffix(base, "Template")
			}
			// Determine parameters from vars
			var params []string
			var repl = t.Wire
			for _, v := range t.Vars {
				params = append(params, fmt.Sprintf("%s string", camel(v.Name)))
				repl = strings.ReplaceAll(repl, "{"+v.Name+"}", "%s")
			}
			fmt.Fprintf(&buf, "// %sSubject builds subject from template %s.\n", base, toExported(t.Name))
			fmt.Fprintf(&buf, "func %sSubject(%s) NatsSubject {\n", base, strings.Join(params, ", "))
			if len(params) == 0 {
				fmt.Fprintf(&buf, "\treturn NatsSubject(%q)\n", t.Wire)
			} else {
				fmt.Fprintf(&buf, "\treturn NatsSubject(fmt.Sprintf(%q, %s))\n", repl, joinParamNames(params))
			}
			fmt.Fprintf(&buf, "}\n\n")
		}
	}

	return buf.String()
}

func toExported(name string) string {
	parts := strings.Split(strings.ToLower(name), "_")
	for i, p := range parts {
		if p == "" {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + p[1:]
	}
	return strings.Join(parts, "")
}

func camel(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		if parts[i] == "" {
			continue
		}
		if i == 0 {
			continue
		}
		parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
	}
	return strings.Join(parts, "")
}

func joinParamNames(params []string) string {
	var names []string
	for _, p := range params {
		names = append(names, strings.Split(p, " ")[0])
	}
	return strings.Join(names, ", ")
}

func sanitizeComment(s string) string {
	s = strings.TrimSpace(s)
	s = strings.ReplaceAll(s, "\n", " ")
	return s
}

func toPlural(s string) string {
	if strings.HasSuffix(s, "s") {
		return s + "es"
	}
	return s + "s"
}
