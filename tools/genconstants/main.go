// Code generator for constants.yaml -> constants_gen.go
// Usage: genconstants -in libs/constant/constants.yaml -out libs/constant/constants_gen.go
package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"os"
	"sort"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

type Spec struct {
	Version   int         `yaml:"version"`
	Enums     []EnumSpec  `yaml:"enums"`
	Constants []ConstSpec `yaml:"constants"`
}

type EnumSpec struct {
	Name        string      `yaml:"name"`
	Description string      `yaml:"description"`
	Values      []EnumValue `yaml:"values"`
}

type EnumValue struct {
	Name        string `yaml:"name"`
	Value       string `yaml:"value"`
	Description string `yaml:"description"`
}

type ConstSpec struct {
	Name        string        `yaml:"name"`
	Group       string        `yaml:"group"`
	Wire        string        `yaml:"wire"`
	ValueKind   string        `yaml:"value_kind"`
	Description string        `yaml:"description"`
	Vars        []TemplateVar `yaml:"vars"`
}

type TemplateVar struct {
	Name        string `yaml:"name"`
	Kind        string `yaml:"kind"`
	Description string `yaml:"description"`
}

func main() {
	in := flag.String("in", "", "input YAML spec path")
	out := flag.String("out", "", "output Go file path")
	pkg := flag.String("package", "constant", "Go package name for generated code")
	mode := flag.String("mode", "constants", "generation mode: constants | descriptors")
	flag.Parse()

	if *in == "" || *out == "" {
		flag.Usage()
		os.Exit(2)
	}

	data, err := os.ReadFile(*in)
	must(err)

	var spec Spec
	if err := yaml.Unmarshal(data, &spec); err != nil {
		must(fmt.Errorf("parse yaml: %w", err))
	}

	must(validate(spec))

	var code string
	switch *mode {
	case "constants":
		code = generate(spec, *pkg, *in)
	case "descriptors":
		code = generateDescriptors(spec, *pkg, *in)
	default:
		must(fmt.Errorf("unknown mode: %s", *mode))
	}

	must(os.WriteFile(*out, []byte(code), 0o644))
}

func must(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

func validate(spec Spec) error {
	// Validate enums
	seenEnumTypes := map[string]struct{}{}
	for _, e := range spec.Enums {
		if e.Name == "" {
			return errors.New("enum with empty name")
		}
		if _, exists := seenEnumTypes[e.Name]; exists {
			return fmt.Errorf("duplicate enum name: %s", e.Name)
		}
		seenEnumTypes[e.Name] = struct{}{}
		if len(e.Values) == 0 {
			return fmt.Errorf("enum %s has no values", e.Name)
		}
		seenValueNames := map[string]struct{}{}
		seenWireValues := map[string]struct{}{}
		for _, v := range e.Values {
			if v.Name == "" {
				return fmt.Errorf("enum %s has value with empty name", e.Name)
			}
			if v.Value == "" {
				return fmt.Errorf("enum %s value %s has empty wire value", e.Name, v.Name)
			}
			if _, ok := seenValueNames[v.Name]; ok {
				return fmt.Errorf("enum %s duplicate value name: %s", e.Name, v.Name)
			}
			if _, ok := seenWireValues[v.Value]; ok {
				return fmt.Errorf("enum %s duplicate wire value: %s", e.Name, v.Value)
			}
			seenValueNames[v.Name] = struct{}{}
			seenWireValues[v.Value] = struct{}{}
		}
	}

	seenNames := map[string]struct{}{}
	for _, c := range spec.Constants {
		if c.Name == "" {
			return errors.New("constant with empty name")
		}
		if _, ok := seenNames[c.Name]; ok {
			return fmt.Errorf("duplicate constant name: %s", c.Name)
		}
		seenNames[c.Name] = struct{}{}
		switch c.Group {
		case "annotations", "labels", "nats_subjects", "kv_buckets", "subject_templates":
		default:
			return fmt.Errorf("unknown group %q for %s", c.Group, c.Name)
		}
		if c.Wire == "" {
			return fmt.Errorf("wire empty for %s", c.Name)
		}
	}
	return nil
}

func generate(spec Spec, pkg, sourcePath string) string {
	var buf bytes.Buffer
	now := time.Now().UTC().Format(time.RFC3339)
	fmt.Fprintf(&buf, "// Code generated by genconstants; DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// Source: %s\n", sourcePath)
	fmt.Fprintf(&buf, "// Generated at: %s\n\n", now)
	fmt.Fprintf(&buf, "package %s\n\n", pkg)
	// Import fmt only if needed for subject template formatting.
	needsFmt := false
	for _, c := range spec.Constants {
		if c.Group == "subject_templates" {
			needsFmt = true
			break
		}
	}
	if needsFmt {
		fmt.Fprintf(&buf, "import \"fmt\"\n\n")
	}

	// Enums
	if len(spec.Enums) > 0 {
		for _, e := range spec.Enums {
			// Type
			fmt.Fprintf(&buf, "// %s enum\n", e.Name)
			fmt.Fprintf(&buf, "type %s string\n\n", e.Name)
			// Values
			fmt.Fprintf(&buf, "const (\n")
			for _, v := range e.Values {
				fmt.Fprintf(&buf, "\t// %s: %s\n", v.Name, sanitizeComment(v.Description))
				fmt.Fprintf(&buf, "\t%s %s = %q\n", toExported(v.Name), e.Name, v.Value)
			}
			fmt.Fprintf(&buf, ")\n\n")
			// Slice
			fmt.Fprintf(&buf, "var All%ss = []%s{\n", e.Name, e.Name)
			for _, v := range e.Values {
				fmt.Fprintf(&buf, "\t%s,\n", toExported(v.Name))
			}
			fmt.Fprintf(&buf, "}\n\n")
		}
	}

	// Type declarations
	typeMap := map[string]string{
		"annotations":       "AnnotationKey",
		"labels":            "LabelKey",
		"nats_subjects":     "NatsSubject",
		"kv_buckets":        "KvBucket",
		"subject_templates": "SubjectTemplate",
	}
	var groups []string
	for g := range typeMap {
		groups = append(groups, g)
	}
	sort.Strings(groups)

	for _, g := range groups {
		fmt.Fprintf(&buf, "type %s string\n\n", typeMap[g])
	}

	// Collect constants per group
	perGroup := map[string][]ConstSpec{}
	for _, c := range spec.Constants {
		perGroup[c.Group] = append(perGroup[c.Group], c)
	}
	for g, list := range perGroup {
		sort.Slice(list, func(i, j int) bool { return list[i].Name < list[j].Name })
		perGroup[g] = list
	}

	// Emit const blocks
	for _, g := range groups {
		list := perGroup[g]
		if len(list) == 0 {
			continue
		}
		fmt.Fprintf(&buf, "const (\n")
		for _, c := range list {
			typ := typeMap[g]
			fmt.Fprintf(&buf, "\t// %s: %s\n", c.Name, sanitizeComment(c.Description))
			fmt.Fprintf(&buf, "\t%s %s = %q\n", toExported(c.Name), typ, c.Wire)
		}
		fmt.Fprintf(&buf, ")\n\n")
		// Slice export
		fmt.Fprintf(&buf, "var All%s = []%s{\n", toPlural(typeMap[g]), typeMap[g])
		for _, c := range list {
			fmt.Fprintf(&buf, "\t%s,\n", toExported(c.Name))
		}
		fmt.Fprintf(&buf, "}\n\n")
	}

	// Template builders (forward only)
	if ts := perGroup["subject_templates"]; len(ts) > 0 {
		for _, t := range ts {
			// Build function name: strip _TEMPLATE suffix
			base := strings.TrimSuffix(toExported(t.Name), "Template")
			if base == toExported(t.Name) && strings.HasSuffix(base, "Template") {
				base = strings.TrimSuffix(base, "Template")
			}
			// Determine parameters from vars
			var params []string
			repl := t.Wire
			for _, v := range t.Vars {
				params = append(params, fmt.Sprintf("%s string", camel(v.Name)))
				repl = strings.ReplaceAll(repl, "{"+v.Name+"}", "%s")
			}
			fmt.Fprintf(&buf, "// %sSubject builds subject from template %s.\n", base, toExported(t.Name))
			fmt.Fprintf(&buf, "func %sSubject(%s) NatsSubject {\n", base, strings.Join(params, ", "))
			if len(params) == 0 {
				fmt.Fprintf(&buf, "\treturn NatsSubject(%q)\n", t.Wire)
			} else {
				fmt.Fprintf(&buf, "\treturn NatsSubject(fmt.Sprintf(%q, %s))\n", repl, joinParamNames(params))
			}
			fmt.Fprintf(&buf, "}\n\n")
		}
	}

	return buf.String()
}

// generateDescriptors emits a Go file that declares typed descriptor variables for annotations
// based on value_kind. It targets the metadata package by default, but the package is configurable.
func generateDescriptors(spec Spec, pkg, sourcePath string) string {
	var buf bytes.Buffer
	now := time.Now().UTC().Format(time.RFC3339)
	fmt.Fprintf(&buf, "// Code generated by genconstants (descriptors); DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// Source: %s\n", sourcePath)
	fmt.Fprintf(&buf, "// Generated at: %s\n\n", now)
	fmt.Fprintf(&buf, "package %s\n\n", pkg)

	// Collect annotation constants from spec and determine needsTime up front.
	type ann struct{ Name, ValueKind string }
	anns := []ann{}
	needsTime := false
	for _, c := range spec.Constants {
		if c.Group == "annotations" {
			anns = append(anns, ann{Name: toExported(c.Name), ValueKind: c.ValueKind})
			if c.ValueKind == "rfc3339_timestamp" {
				needsTime = true
			}
		}
	}

	// subject_templates not used in descriptors mode

	// Decide imports and qualification
	needConstImport := pkg != "constant"
	var imports []string
	if needConstImport {
		imports = append(imports, "\"github.com/bafbi/stellaroot/libs/constant\"")
	}
	if needsTime {
		imports = append(imports, "\"time\"")
	}
	if len(imports) > 0 {
		fmt.Fprintf(&buf, "import (\n")
		for _, imp := range imports {
			fmt.Fprintf(&buf, "\t%s\n", imp)
		}
		fmt.Fprintf(&buf, ")\n\n")
	}

	qual := ""
	if needConstImport {
		qual = "constant."
	}

	// Emit descriptors
	for _, a := range anns {
		switch {
		case a.ValueKind == "boolean":
			fmt.Fprintf(&buf, "var %sDesc = %sNewBoolAnnotationDesc(%s%s)\n", a.Name, qual, qual, a.Name)
		case a.ValueKind == "string":
			fmt.Fprintf(&buf, "var %sDesc = %sNewStringAnnotationDesc(%s%s)\n", a.Name, qual, qual, a.Name)
		case a.ValueKind == "rfc3339_timestamp":
			fmt.Fprintf(&buf, "var %sDesc = %sNewTimeAnnotationDesc(%s%s, time.RFC3339)\n", a.Name, qual, qual, a.Name)
		default:
			// enum:Foo -> generate enum descriptor if pattern matches
			const prefix = "enum:"
			if strings.HasPrefix(a.ValueKind, prefix) {
				enumType := strings.TrimPrefix(a.ValueKind, prefix)
				// All<EnumType>s slice name follows our simple pluralization rule
				fmt.Fprintf(&buf, "var %sDesc = %sNewEnumAnnotationDesc[%s](%s%s, %sAll%ss)\n", a.Name, qual, enumType, qual, a.Name, qual, enumType)
			} else if a.ValueKind == "uuid" {
				fmt.Fprintf(&buf, "var %sDesc = %sNewUUIDAnnotationDesc(%s%s)\n", a.Name, qual, qual, a.Name)
			} else {
				// Fallback to string
				fmt.Fprintf(&buf, "// WARNING: unknown value_kind %q for %s, defaulting to string descriptor.\n", a.ValueKind, a.Name)
				fmt.Fprintf(&buf, "var %sDesc = %sNewStringAnnotationDesc(%s%s)\n", a.Name, qual, qual, a.Name)
			}
		}
	}

	return buf.String()
}

func toExported(name string) string {
	parts := strings.Split(strings.ToLower(name), "_")
	for i, p := range parts {
		if p == "" {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + p[1:]
	}
	return strings.Join(parts, "")
}

func camel(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		if parts[i] == "" {
			continue
		}
		if i == 0 {
			continue
		}
		parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
	}
	return strings.Join(parts, "")
}

func joinParamNames(params []string) string {
	var names []string
	for _, p := range params {
		names = append(names, strings.Split(p, " ")[0])
	}
	return strings.Join(names, ", ")
}

func sanitizeComment(s string) string {
	s = strings.TrimSpace(s)
	s = strings.ReplaceAll(s, "\n", " ")
	return s
}

func toPlural(s string) string {
	if strings.HasSuffix(s, "s") {
		return s + "es"
	}
	return s + "s"
}
